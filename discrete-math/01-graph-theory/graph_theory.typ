#import "../../typst-lib/main.typ": *
#import "../../typst-lib/dmt.typ": *

#set text(size: 14pt)

#notes-header([Теория графов])

#notes-sub([Основы])

#def(
  [Граф],
  [
    пара $pair(V, E)$, где
    - $V$ --- конечное множество вершин
    - $E$ --- множество ребер

    Дополнительные обозначения:
    - $V(G)$ --- множество вершин
    - $E(G)$ --- множество ребер
    - $abs(V(G))$ --- порядок графа
    - $abs(E(G))$ --- размер графа
  ],
)

Ребра графа --- произвольные объекты, представляющие привычные нам ребра в удобном в конкретной задаче виде (например, в неориентированных графах ни к чему хранить их в виде _упорядоченных пар_ можно хранить их в виде 2- и 1-множеств). Взаимодействие с ними строятся на функциях, например, для описания взвешенного ориентированного графа можно воспользоваться 3 функциями:
$
  & "begin" : E -> V \
  & "end" : E -> V \
  & "weight" : E -> RR \
$

#fun-fact-headered(
  [Полезная нотация],
  [
    Множество всех подмножеств $X$, имеющих мощность $n$, можно записать как
    $
      vec(X, n) = {S | S in cal(P)(X) and abs(S) = n}
    $
    такой нотацией можно пользоваться для записи
  ],
)

#notes-sub([Классификация графов], pgbreak: true)

Введем полезные определения

#def(
  [Петля],
  [
    ребро, начинающееся и заканчивающееся в одной и той же вершние:
    $
      l in E : "begin"(l) = "end"(l)
    $
  ],
)
#def(
  [Мультребро],
  [
    ребро, для которого в множестве ребер существует его точная копия, неравная ему:
    $
      m in E : (exists m' in E smn {m})(forall f in F)(f(m') = f(m))
    $
    Иногда пару мультиребер называют _ кратными ребрами _
  ],
)

Теперь легко классифицировать графы, основываясь на наличии в них петель и мультиребер:

#def(
  [Простой граф],
  [
    граф, среди ребер которого нет *ни петель, ни мультиребер*
  ],
)
#def(
  [Мультиграф],
  [граф, среди ребер которого *нет петель* (мультиребра допускаются)],
)
#def(
  [Псевдограф],
  [граф, в котором *допускаются* и мультиребра и петли],
)

Ну и еще один чуть более интересный вид графов и ребер

#def(
  [Гиперребро],
  [ребро, связывающее больше 2 вершин],
)
#def(
  [Гиперграф],
  [граф, содержащий гиперребра],
)

#notes-sub([Про вершины], pgbreak: true)

_ Здесь определения будут поясняться на примере неориентированных и невзвешенных графов, однако обобщить эти их на другие виды никакой сложности не представляет _

#def(
  [Связанные (adjacent) вершины],
  [вершины, между которыми есть ребро --- $u$ и $v$, если ${u, v} in E$],
)
#def(
  [Инцидентное ребро],
  [ребро инцидентно вершине, если оно в нее "приходит" --- $e in E$ инцидентно $u in V$, если $v in e$],
)
#def(
  [Соседние вершины $v$],
  [множество связанных с $v$ вершин: $ {u | {u, v} in E} $],
)

#def(
  [Степень вершины],
  [количество ее соседей: $ deg (u) = abs({v | {u, v} in E}) $],
)
#fun-fact(
  [
    Граф, к слову тоже имеет степени (даже 2):
    - $delta(G) = limits(min)_(v in V)deg v$ --- минимальная степень ребра
    - $Delta(G) = limits(max)_(v in V)deg v$ --- максимальная степень ребра
  ],
)
#def(
  [Степенная последовательность],
  [последовательность степеней вершин графа в порядке невозрастания],
)

#theorem(
  name: [Лемма о рукопожатиях],
  [
    В любом (неориентированном) графе сумма степеней вершин в 2 раза больше количества ребер:
    $
      limits(sum)_(v in V) deg(v) = 2 dot abs(E)
    $
  ],
  [
    Каждое ребро добавляет к итоговой сумме по 2 (каждым из 2 концов), а значит, пройдясь по всем ребрам получим сумму всех степеней равную $2 dot abs(E)$
  ],
)

#notes-sub([Возвращаясь к графам], pgbreak: true)
#def(
  [r-regular граф],
  [граф, в котором каждая вершина имеет степень $r$],
)

#fun-fact-headered(
  [Специальные графы],
  [
    - *Нулевой* --- без вершин
    - *Тривиальный* --- одна вершина, нет ребер
    - *Пустой ($compl(K)_n$)* --- $n$ вершин, нет ребер
    - *Полный ($K_n$)* --- $n$ вершин, все соединены между собой
    - *Цикл ($C_n$)* --- $n$ вершин в цикле
    - *Путь ($P_n$)* --- $n$ вершин в линию
  ],
)

#notes-sub([Способы представления графов], pgbreak: true)
#def(
  [Матрица связности],
  [
    для графа с $n$ вершинами матрицей связности будет матрица размера $n times n$, элементы которой задаются по следующим правилам
    $
      A_(i j) = cases(1"," {v_i, v_j} in E, 0 "иначе")
    $
    Пара легкопроверяемых фактов:
    - Матрицы связности неориентированных графов симметричны относительно главной диагонали
    - В простом графе главная диагональ заполнена нулями
  ],
)
#def(
  [Список связности],
  [
    каждой вершине ставится в соответствие множество ее соседей
  ],
)

#notes-sub([Подграфы], pgbreak: true)

#def(
  [Подграф],
  [
    $H = pair(V', E')$ называется подграфом $G = pair(V, E)$, если множества его вершин и ребер являются подмножествами соответствующих множеств $G$:
    $
      H subset.eq G <==> V' subset.eq V "и" E' subset.eq E
    $
  ],
)
Подграфы бывают 2 видов:
+ *Spanning* (открыт для предложений перевода) --- подграф, содержащий все вершины исходного ($V' = V$)
+ *Induced* (вероятно, порожденный) --- подграф $G[S]$, где $S subset.eq V$, в котором есть все ребра, содержащие вершины исходного:
  $
    E' = {{u, v} | u, v in S "и" {u, v} in E}
  $

#notes-header([Изоморфизм графов], pgbreak: true)
#def(
  [Изоморфные графы],
  [
    $G_1 = pair(V_1, E_1)$ и $G_2 = pair(V_2, E_2)$, для которых существует биекция $phi : V_1 -> V_2$, сохраняющая связность:
    $
      {u, v} in E_1 <==> {phi(u), phi(v)} in E_2
    $
    По сути это 2 одинаковых графа, в которых по-разному названы вершины, их структура идентична
  ],
)
