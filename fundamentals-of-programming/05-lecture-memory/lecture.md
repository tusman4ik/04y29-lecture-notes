Работа программ:
- Архитектура фон неймана/гарвардская
- Виды памяти
- Процессор
- Прерывания

регистры, кэш, оперативка, ссд, хдд

чем больше объем тем меньше скорость

# Процессы/потоки

Процессы:
- независимое адерснле пространство
- объекты ядра (файловые дескрипторы, объекты синхронизации и.т.д.)

Потоки:
- набор команд
- стек

Один процесс состоит из >=1 потока

# Виртуальное адресное пространство
1. У каждого процесса "своя" память
2. Иллюзия доступности всех ресуросов
3. Осуществляется маппинг на физическую память (вирт. пространство связано с физ. памятью не напрямую)
4. Page Table
5. Segments
6. ОС также реализует данную логику

# Page table
- Маппинг вирт. адреса на физический
- Изоляция процессов
- Memory-mapped file
- Обеспечение безопасного режима работы ОС
- Swapping

# Представление программы в памяти

Вирт. адр. пр-во побито на 2 куска:
1. Kernel space — привелигированная область памяти, где ОС хранит крутой важный код, доступа нету
2. User mode space

Segments:
1. Stack
2. Heap
3. Memory mapping
4. BSS
5. Data
6. Text

#TODO важно про сегменты расписать, точно с кодом и терминалом

В момент выполнения программы меняются только стек и куча

# Стек вызовов

Сегмент stack используется для машинерии вызова функций

Структура стека:
1. StackFrame — знания про вызываемую функцию
	1. arguments
	2. local variable
	3. return point
2. cdecl, stcall, fastcall
3. Регистры процессора (x86)
	1. esp/rsp (верхушка стека)
	2. ebp/rbp (начало текущего стекфрейма)
	3. eax (результат)

#TODO gotbolt.org глянуть пример в ассемблере, в идеале еще картинками визуализировать

философия — при завершении функции иметь возможность размотать стек обратно
Переполнение стека:
- глубокая рекурсия
- тумач объём данных

стек мб хранится в кэше процессора
поэтому доступ к стеку быстрый и крутой

в рамках одного процесса может быть много стеков (каждый под свой поток)

# Куча

1. в отличие от стека позволяет создавать динам. струкутры большого размера
2. управление жизнью объектов в куче "ручное"

# Функции работы с памятью из stdlib.h

- malloc (неявно кастуется)
  не гарантирует что память ваще будет выделена, тогда вернет нулл
- free
  очищает память (если не делать то утечка памяти)
- calloc
- realloc

Круто:
- new
- delete

# SEGFAAAAAAAAAAAAAULT
 #TODO