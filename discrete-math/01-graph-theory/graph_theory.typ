#import "../../typst-lib/main.typ": *
#import "../../typst-lib/dmt.typ": *

#set text(size: 14pt)

#notes-header([Теория графов])

#notes-sub([Основы])

#def(
  [Граф],
  [
    пара $pair(V, E)$, где
    - $V$ --- конечное множество вершин
    - $E$ --- множество ребер

    Дополнительные обозначения:
    - $V(G)$ --- множество вершин
    - $E(G)$ --- множество ребер
    - $abs(V(G))$ --- порядок графа
    - $abs(E(G))$ --- размер графа
  ],
)

Ребра графа --- произвольные объекты, представляющие привычные нам ребра в удобном в конкретной задаче виде (например, в неориентированных графах ни к чему хранить их в виде _упорядоченных пар_ можно хранить их в виде 2- и 1-множеств). Взаимодействие с ними строятся на функциях, например, для описания взвешенного ориентированного графа можно воспользоваться 3 функциями:
$
  & "begin" : E -> V \
  & "end" : E -> V \
  & "weight" : E -> RR \
$

#fun-fact-headered(
  [Полезная нотация],
  [
    Множество всех подмножеств $X$, имеющих мощность $n$, можно записать как
    $
      vec(X, n) = {S | S subset.eq X "и" abs(S) = n}
    $
  ],
)

#fun-fact-headered(
  [Заметка об определении графов],
  [
    Есть несколько способов определить граф

    - Наиболее абстрактный способ определить граф, это через функции (написаны выше), тогда E - множество анонимных названий ребер

    - Можно прямо в множество ребер пихать не анонимные элементы, а пары элементов (для направленных графов), начало и конец.

      Тогда $E subset.eq V^2$ Мы просто говорим о том, что граф это отношение.

      Для взвешенного графа $E subset.eq V^2 times RR$

    - Для ненаправленных Графов можно сделать то же самое только с неупорядоченными парами.

      Обозначается $E subset.eq vec(V, 2) union vec(V, 1)$

      Несложно видеть, что
      $C^2_(|V|) = abs(vec(V, 2))$


  ],
)

#notes-sub([Классификация графов], pgbreak: true)

Введем полезные определения

#def(
  [Петля],
  [
    ребро, начинающееся и заканчивающееся в одной и той же вершние:
    $
      l in E : "begin"(l) = "end"(l)
    $
  ],
)
#def(
  [Мультиребро],
  [
    ребро, для которого в множестве ребер существует его точная копия, неравная ему:
    $
      m in E : (exists m' in E smn {m})(forall f in F)(f(m') = f(m))
    $
    Иногда пару мультиребер называют _ кратными ребрами _
  ],
)

Теперь легко классифицировать графы, основываясь на наличии в них петель и мультиребер:

#def(
  [Простой граф],
  [
    граф, среди ребер которого нет *ни петель, ни мультиребер*
  ],
)

#fun-fact-headered(
  [Определение внутри курса],
  [
    Когда Чухарев (и мы следовательно) говорим слово граф, мы имеем в виду простой граф, если не сказано обратного
  ],
)
#def(
  [Мультиграф],
  [граф, среди ребер которого *нет петель* (мультиребра допускаются)],
)
#def(
  [Псевдограф],
  [граф, в котором *допускаются* и мультиребра и петли],
)

Ну и еще один чуть более интересный вид графов и ребер

#def(
  [Гиперребро],
  [ребро, связывающее больше 2 вершин],
)
#def(
  [Гиперграф],
  [граф, содержащий гиперребра],
)

#notes-sub([Про вершины], pgbreak: true)

_ Здесь определения будут поясняться на примере неориентированных и невзвешенных графов, однако обобщить их на другие виды никакой сложности не представляет _

#def(
  [Смежные (adjacent) вершины],
  [вершины, между которыми есть ребро --- $u$ и $v$, если ${u, v} in E$],
)
#def(
  [Инцидентное ребро],
  [ребро инцидентно вершине, если оно в нее "приходит" --- $e in E$ инцидентно $u in V$, если $v in e$
    (так же определяют как обратное, ребро которое выходит из вершины)
  ],
)
#def(
  [Соседние вершины $v$],
  [множество смежных с $v$ вершин: $ {u | {u, v} in E} $],
)

#def(
  [Степень вершины],
  [количество ее соседей: $ deg (u) = abs({v | {u, v} in E}) $],
)
#fun-fact(
  [
    Граф, к слову тоже имеет степени (даже 2):
    - $delta(G) = limits(min)_(v in V)deg v$ --- минимальная степень вершины в графе
    - $Delta(G) = limits(max)_(v in V)deg v$ --- максимальная степень вершины в графе
  ],
)
#def(
  [Степенная последовательность],
  [последовательность степеней вершин графа в порядке невозрастания],
)

#theorem(
  name: [Лемма о рукопожатиях],
  [
    В любом (неориентированном) графе сумма степеней вершин в 2 раза больше количества ребер:
    $
      limits(sum)_(v in V) deg(v) = 2 dot abs(E)
    $
  ],
  [
    Каждое ребро добавляет к итоговой сумме по 2 (каждым из 2 концов), а значит, пройдясь по всем ребрам получим сумму всех степеней равную $2 dot abs(E)$
  ],
)

#notes-sub([Возвращаясь к графам], pgbreak: true)
#def(
  [r-regular граф],
  [граф, в котором каждая вершина имеет степень $r$],
)

#fun-fact-headered(
  [Специальные графы],
  [
    - *Нулевой* --- без вершин
    - *Тривиальный* --- одна вершина, нет ребер
    - *Пустой ($compl(K)_n$)* --- $n$ вершин, нет ребер
    - *Полный ($K_n$)* --- $n$ вершин, все соединены между собой
    - *Цикл ($C_n$)* --- $n$ вершин в цикле
    - *Путь ($P_n$)* --- $n$ вершин в линию
  ],
)

#theorem(
  // name: [ТЕОРЕМА 2],
  [
    *Полный ($K_n$)* граф имеет ровно $mat(n; 2) = (n(n-1))/2$ ребер
  ],
  [
    Лемма о рукопожатиях:
    $
      & limits(sum)_(v in V) deg(v) = 2 dot abs(E) \
      & abs(E) = (limits(sum)_(v in V) deg(v)) /2
    $
    поскольку в графе $n$ вершин, каждая из которых связана со всеми остальными справедливо, что
    $
      abs(E) = (n (n -1))/2
    $
  ],
)

#notes-sub([Способы представления графов], pgbreak: true)
#def(
  [Матрица смежности],
  [
    для графа с $n$ вершинами матрицей смежности будет матрица размера $n times n$, элементы которой задаются по следующему правилу
    $
      A_(i j) = cases(1"," {v_i, v_j} in E, 0 "иначе")
    $
    Пара легкопроверяемых фактов:
    - Матрицы смежности неориентированных графов симметричны относительно главной диагонали
    - В простом графе главная диагональ заполнена нулями
  ],
)
#def(
  [Список смежности],
  [
    каждой вершине ставится в соответствие множество ее соседей
  ],
)

#notes-sub([Подграфы], pgbreak: true)

#def(
  [Подграф],
  [
    $H = pair(V', E')$ называется подграфом $G = pair(V, E)$, если множества его вершин и ребер являются подмножествами соответствующих множеств $G$:
    $
      H subset.eq G <==> V' subset.eq V "и" E' subset.eq E
    $
  ],
)
Особые виды подграфов:
+ *Spanning* (открыт для предложений перевода) --- подграф, содержащий все вершины исходного ($V' = V$)
+ *Induced* (вероятно, порожденный) --- подграф $G[S]$, где $S subset.eq V$, в котором есть все ребра, содержащие вершины исходного:
  $
    E' = {{u, v} | u, v in S "и" {u, v} in E}
  $

#notes-sub([Изоморфизм графов], pgbreak: true)
#def(
  [Изоморфные графы],
  [
    $G_1 = pair(V_1, E_1)$ и $G_2 = pair(V_2, E_2)$, для которых существует биекция $phi : V_1 -> V_2$, сохраняющая связность:
    $
      {u, v} in E_1 <==> {phi(u), phi(v)} in E_2
    $
    По сути это 2 одинаковых графа, в которых по-разному названы вершины, их структура идентична
  ],
)

#fun-fact-headered(
  [Смысл изоморфизма графов],
  [
    Глазами определить изоморфны ли нарисованные на бумажке графы очень легко (буквально одинаковые графы)

    Вся сложность задачи в алгоритмизации этого процесса, чтобы это могла делать машина.
  ],
)

#notes-header([Пути и связность], pgbreak: true)

#notes-sub([Пути])

#def(
  [Walk (переводить запрещено)],
  [
    переменная последовательность вершин и ребер.

    Замкнутый walk так и называется
  ],
)
#def(
  [Trail (переводить запрещено)],
  [
    walk, в котором ребра не повторяются.

    Замкнутый trail --- circuit
  ],
)
#def(
  [Путь (path)],
  [
    trail, в котором вершины не повторяются.

    Замкнутый путь --- цикл
  ],
)

Путь (и все остальные) называются замкнутыми если начинаются и заканчиваются в одной и той же вершине (в path допускается только такое повторение вершин)

#def(
  [Длина пути (и проч.)],
  [
    количество ребер в нем
  ],
)
#def(
  [Расстояние (между $u, v$)],
  [
    длина кратчайшего пути между $u$ и $v$. Если пути не существует, пишут $"dist"(u, v) = oo$
  ],
)

#theorem(
  [Расстояние --- метрика],
  [
    Проверить свойства несложно, доказательство тривиально
  ],
)

#fun-fact-headered(
  [Характеристики вершин и графов, связанные с расстоянием],
  [
    - *Эксцентриситет* вершины --- расстояние от нее до самой удаленной вершины ($"ecc"(v) = limits(max)_(u in V) "dist"(u, v)$)
    - *Радиус* графа --- минимальный эксцентриситет его вершин
    - *Диаметр* графа --- максимальный эксцентриситет его вершин
    - *Центр* графа --- множество вершин, эксцентриситет которых равен его радиусу
  ],
)

#theorem(
  [$ "rad"(G) <= "diam"(G) <= 2 dot "rad"(G) $],
  [
    - $"rad"(G) <= "diam"(G)$ --- очевидно из определения
    - Пусть $"diam"(G) = "dist"(u, v)$, а $w$ --- один из центров графа, тогда
    $
      "dist"(u, v) <= underbracket("dist"(u, w), <= "rad"(G)) + underbracket("dist"(w, v), <= "rad"(G)) <= 2 dot "rad"(G)
    $
  ],
)


#notes-sub([Связность], pgbreak: true)
#def(
  [Связность вершин],
  [
    вершины связаны если существует путь из одной в дргуую
  ],
)
#def(
  [Связность графа],
  [
    граф называется связным, если все его вершины связаны
  ],
)

#theorem(
  [Из существования walk следует существование пути],
  [
    Рассмотрим минимальный (по включению) walk, если есть повторяющиеся вершины получим противоречие --- walk не минимальный, откуда следует, что повторяющихся вершин (а значит и ребер) нет, а значит рассмотренный walk --- путь (если есть walk короче, также получим противоречие)
  ],
)

#def(
  [Компонента связности],
  [максимальный связный подграф],
)

Эти определения касались неориентированного графа, теперь что касается ориентированного.

#def(
  [Слабая связность],
  [
    если все ребра считать двунаправленными, граф становится связным
  ],
)
#def(
  [Полусвязность],
  [для любых двух вершин либо сущестует путь $u->v$ или $v->u$],
)
#def(
  [Сильная связность],
  [для любых двух вершин существует путь $u->v$ и $v->u$],
)

#def(
  [Компонента сильной связности],
  [
    максимальный сильно связный подграф ориентированного графа
  ],
)

#def(
  [Обхват (girth) графа],
  [
    длина кратчайшего цикла. Для ацикличного графа $"girth"(G) = oo$
  ],
)

#notes-header([Деревья и леса], pgbreak: true)

#def(
  [Дерево],
  [связный граф без циклов],
)
#def(
  [Лес],
  [граф без циклов],
)

#theorem(
  [
    Для графа $G$ с $n$ вершинами справедливо, что все следующие факты эквивалентны
    :
    + $G$ --- дерево
    + $G$ связный с $n-1$ ребром
    + $G$ ацикличный с $n-1$ ребром
    + Любые 2 вершины связаны единственным путем
    + $G$ минимально связный (удаление любого ребра нарушает связность)
    + $G$ максимально ацикличный (добавление любого ребра порождает цикл)
  ],
  [
    Докажем следствие $1 ==> 2 ==> 3 ==> 4 ==> 5 ==> 6 ==> 1$:

    - ($1 ==> 2$) Покажем, что не может быть меньше чем $n-1$ ребро. Рассмотрим граф из $n$ вершин без ребер, в нем $n$ компонент связности. Каждое ребро может соединить 2 вершины из одной компоненты связности (не изменить количество компонент связности) или из разных (уменьшить количество компонент связности на 1, если возможно), а значит чтобы граф был связным, нужно не меньше чем $n-1$ ребро. Теперь докажем, что если граф связный, то добавление любого ребра порождает цикл. Пусть добавилось ребро $e = {u, v}$, по предположению $u$ и $v$ связаны, то есть теперь есть путь из $u$ в $v$ (уже существовавший, без ребра $e$) и путь из $v$ в $u$ (по ребру $e$) --- цикл, а значит, если граф с $n-1$ вершиной связный, то больше в дереве быть уже не может (иначе появляется цикл)
    - *_Дальше лень_*\ Как-то же можно там... подумать что-ли
  ],
)

#def(
  [Подвешенное дерево (дерево с корнем)],
  [
    дерево, в котором одна вершина объявлена _корнем_.

    В подвешенном дереве (по опрределению)
    - Предок $v$ --- это сосед $v$ на пути к корню
    - Дети $v$ --- сосед $v$ вне пути к графу
    - Лист --- вершина без детей
    - Внутренняя вершина --- вершина с хотя бы 1 ребенком
  ],
)

#def(
  [Порожденное дерево],
  [
    порожденный подграф, являющийся деревом
  ],
)

#theorem(
  [Любой связный граф порождает хотя бы одно дерево],
  [
    Воспользуемся DFS --- если попадаем в вершину в которой уже были удалим последнее (ведущее в нее) ребро, как только алгоритм отработал не останется ни одного цикла, при этом не потеряется связность (удалялись только ребра, порождающие циклы)
  ],
)

Пусть теперь $T$ --- дерево, порожденное графом $G$, для любой вершины $e in E(G) smn E(T)$ граф $T + e$ содержит ровно 1 цикл, называемый фундаментальным циклом $e$ по отношению к дереву $T$

#def(
  [Prüfer-последовательность],
  [
    уникальный способ закодировать именованное дерево последовательностью из $n-2$ названий вершин (при $n$ вершинах)

    *Алгоритм построения*:
    + Выбрать лист с минимальным номером
    + Записать в последовательность его предка
    + Удалить лист
    + Повтоять пока не останется 2 вершины
  ],
)

#theorem(
  name: [Формула Кайли],
  [На $n$ вершинах можно построить ровно $n^(n-2)$ labeled деревьев],
  [
    Если поверить, что Prüfer-последовательность уникально кодирует ровно один граф, то доказательство этого факта очевидно следует из комбинаторики --- $n-2$ места, на каждом из которых стоит одно из $n$ названий вершин: $underbracket(n dot n dot dots dot n, n-2 "штуки") = n^(n-2)$
  ],
)

#notes-header([Теория связности], pgbreak: true)

#def(
  [Точка сочленения],
  [вершина, удаление которой увеличивает количество компонент связности],
)
#def(
  [Мост],
  [ребро, удаление которого увеличивает количество компонент связности],
)

#def(
  [$u$-$v$ разделитель (u-v вершинный срез)],
  [
    множество вершин\ $S subset.eq V smn {u, v}$, такое что в графе $G - S$ вершины $u$ и $v$ не связаны
  ],
)
#def(
  [$u$-$v$ реберный срез],
  [
    множество ребер $F subset.eq E$, при которых в графе $G - F$ вершины $u$ и $v$ лежат в разных компонентах связности
  ],
)

#def(
  [Внутренее непересекающиеся (по вершинам) пути],
  [
    2 пути из $u$ в $v$, которые не имеют общих вершин кроме $u$ и $v$
  ],
)
#def(
  [Внутренее непересекающиеся (по ребра) пути],
  [
    2 пути из $u$ в $v$, которые не имеют общих вершин ребер
  ],
)

#def(
  [Связность вершин],
  [
    $kappa(G)$ минимальное количество вершин, которое нужно удалить, чтобы граф стал несвязным или тривиальным
  ],
)
#def(
  [Связность ребер],
  [
    $lambda(G)$ минимальное количество ребер, которое нужно удалить, чтобы граф стал несвязным или тривиальным
  ],
)

#def(
  [$k$-связный граф],
  [
    граф называется $k$-связным, если $kappa(G) >= k$. Или, что эквивалентно, в $G$ не меньше $k$ вершин и $ (forall S)(abs(S) < k ==> (G-S) -"связный") $
  ],
)
#def(
  [$k$-реберно-связный граф],
  [
    граф называется $k$-реберно-связным, если $lambda(G) >= k$. Или, что эквивалентно, в $G$ не меньше $k$ вершин и $ (forall F)(abs(F) < k ==> (G-F) -"связный") $
  ],
)
