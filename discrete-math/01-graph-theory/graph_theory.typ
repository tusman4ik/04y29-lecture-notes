#import "../../typst-lib/main.typ": *
#import "../../typst-lib/dmt.typ": *

#set text(size: 14pt)

#notes-header([Теория графов])

#notes-sub([Основы])

#def(
  [Граф],
  [
    пара $pair(V, E)$, где
    - $V$ --- конечное множество вершин
    - $E$ --- множество ребер

    Дополнительные обозначения:
    - $V(G)$ --- множество вершин
    - $E(G)$ --- множество ребер
    - $abs(V(G))$ --- порядок графа
    - $abs(E(G))$ --- размер графа
  ],
)

Ребра графа --- произвольные объекты, представляющие привычные нам ребра в удобном в конкретной задаче виде (например, в неориентированных графах ни к чему хранить их в виде _упорядоченных пар_ можно хранить их в виде 2- и 1-множеств). Взаимодействие с ними строятся на функциях, например, для описания взвешенного ориентированного графа можно воспользоваться 3 функциями:
$
  & "begin" : E -> V \
  & "end" : E -> V \
  & "weight" : E -> RR \
$

#fun-fact-headered(
  [Полезная нотация],
  [
    Множество всех подмножеств $X$, имеющих мощность $n$, можно записать как
    $
      vec(X, n) = {S | S subset.eq X "и" abs(S) = n}
    $
  ],
)

#fun-fact-headered(
  [Заметка об определении графов],
  [
    Есть несколько способов определить граф

    - Наиболее абстрактный способ определить граф, это через функции (написаны выше), тогда E - множество анонимных названий ребер

    - Можно прямо в множество ребер пихать не анонимные элементы, а пары элементов (для направленных графов), начало и конец.

      Тогда $E subset.eq V^2$ Мы просто говорим о том, что граф это отношение.

      Для взвешенного графа $E subset.eq V^2 times RR$

    - Для ненаправленных Графов можно сделать то же самое только с неупорядоченными парами.

      Обозначается $E subset.eq vec(V, 2) union vec(V, 1)$

      Несложно видеть, что
      $C^2_(|V|) = abs(vec(V, 2))$


  ],
)

#notes-sub([Классификация графов], pgbreak: true)

Введем полезные определения

#def(
  [Петля],
  [
    ребро, начинающееся и заканчивающееся в одной и той же вершние:
    $
      l in E : "begin"(l) = "end"(l)
    $
  ],
)
#def(
  [Мультиребро],
  [
    ребро, для которого в множестве ребер существует его точная копия, неравная ему:
    $
      m in E : (exists m' in E smn {m})(forall f in F)(f(m') = f(m))
    $
    Иногда пару мультиребер называют _ кратными ребрами _
  ],
)

Теперь легко классифицировать графы, основываясь на наличии в них петель и мультиребер:

#def(
  [Простой граф],
  [
    граф, среди ребер которого нет *ни петель, ни мультиребер*
  ],
)

#fun-fact-headered(
  [Определение внутри курса],
  [
    Когда Чухарев (и мы следовательно) говорим слово граф, мы имеем в виду простой граф, если не сказано обратного
  ],
)
#def(
  [Мультиграф],
  [граф, среди ребер которого *нет петель* (мультиребра допускаются)],
)
#def(
  [Псевдограф],
  [граф, в котором *допускаются* и мультиребра и петли],
)

Ну и еще один чуть более интересный вид графов и ребер

#def(
  [Гиперребро],
  [ребро, связывающее больше 2 вершин],
)
#def(
  [Гиперграф],
  [граф, содержащий гиперребра],
)

#notes-sub([Про вершины], pgbreak: true)

_ Здесь определения будут поясняться на примере неориентированных и невзвешенных графов, однако обобщить их на другие виды никакой сложности не представляет _

#def(
  [Смежные (adjacent) вершины],
  [вершины, между которыми есть ребро --- $u$ и $v$, если ${u, v} in E$],
)
#def(
  [Инцидентное ребро],
  [ребро инцидентно вершине, если оно в нее "приходит" --- $e in E$ инцидентно $u in V$, если $v in e$
    (так же определяют как обратное, ребро которое выходит из вершины)
  ],
)
#def(
  [Соседние вершины $v$],
  [множество смежных с $v$ вершин: $ {u | {u, v} in E} $],
)

#def(
  [Степень вершины],
  [количество ее соседей: $ deg (u) = abs({v | {u, v} in E}) $],
)
#fun-fact(
  [
    Граф, к слову тоже имеет степени (даже 2):
    - $delta(G) = limits(min)_(v in V)deg v$ --- минимальная степень вершины в графе
    - $Delta(G) = limits(max)_(v in V)deg v$ --- максимальная степень вершины в графе
  ],
)
#def(
  [Степенная последовательность],
  [последовательность степеней вершин графа в порядке невозрастания],
)

#theorem(
  name: [Лемма о рукопожатиях],
  [
    В любом (неориентированном) графе сумма степеней вершин в 2 раза больше количества ребер:
    $
      limits(sum)_(v in V) deg(v) = 2 dot abs(E)
    $
  ],
  [
    Каждое ребро добавляет к итоговой сумме по 2 (каждым из 2 концов), а значит, пройдясь по всем ребрам получим сумму всех степеней равную $2 dot abs(E)$
  ],
)

#notes-sub([Возвращаясь к графам], pgbreak: true)
#def(
  [r-regular граф],
  [граф, в котором каждая вершина имеет степень $r$],
)

#fun-fact-headered(
  [Специальные графы],
  [
    - *Нулевой* --- без вершин
    - *Тривиальный* --- одна вершина, нет ребер
    - *Пустой ($compl(K)_n$)* --- $n$ вершин, нет ребер
    - *Полный ($K_n$)* --- $n$ вершин, все соединены между собой
    - *Цикл ($C_n$)* --- $n$ вершин в цикле
    - *Путь ($P_n$)* --- $n$ вершин в линию
  ],
)

#theorem(
  // name: [ТЕОРЕМА 2],
  [
    *Полный ($K_n$)* граф имеет ровно $mat(n; 2) = (n(n-1))/2$ ребер
  ],
  [
    Лемма о рукопожатиях:
    $
      & limits(sum)_(v in V) deg(v) = 2 dot abs(E) \
      & abs(E) = (limits(sum)_(v in V) deg(v)) /2
    $
    поскольку в графе $n$ вершин, каждая из которых связана со всеми остальными справедливо, что
    $
      abs(E) = (n (n -1))/2
    $
  ],
)

#notes-sub([Способы представления графов], pgbreak: true)
#def(
  [Матрица смежности],
  [
    для графа с $n$ вершинами матрицей смежности будет матрица размера $n times n$, элементы которой задаются по следующему правилу
    $
      A_(i j) = cases(1"," {v_i, v_j} in E, 0 "иначе")
    $
    Пара легкопроверяемых фактов:
    - Матрицы смежности неориентированных графов симметричны относительно главной диагонали
    - В простом графе главная диагональ заполнена нулями
  ],
)
#def(
  [Список смежности],
  [
    каждой вершине ставится в соответствие множество ее соседей
  ],
)

#notes-sub([Подграфы], pgbreak: true)

#def(
  [Подграф],
  [
    $H = pair(V', E')$ называется подграфом $G = pair(V, E)$, если множества его вершин и ребер являются подмножествами соответствующих множеств $G$:
    $
      H subset.eq G <==> V' subset.eq V "и" E' subset.eq E
    $
  ],
)
Особые виды подграфов:
+ *Spanning* (открыт для предложений перевода) --- подграф, содержащий все вершины исходного ($V' = V$)
+ *Induced* (вероятно, порожденный) --- подграф $G[S]$, где $S subset.eq V$, в котором есть все ребра, содержащие вершины исходного:
  $
    E' = {{u, v} | u, v in S "и" {u, v} in E}
  $

#notes-sub([Изоморфизм графов], pgbreak: true)
#def(
  [Изоморфные графы],
  [
    $G_1 = pair(V_1, E_1)$ и $G_2 = pair(V_2, E_2)$, для которых существует биекция $phi : V_1 -> V_2$, сохраняющая связность:
    $
      {u, v} in E_1 <==> {phi(u), phi(v)} in E_2
    $
    По сути это 2 одинаковых графа, в которых по-разному названы вершины, их структура идентична
  ],
)

#fun-fact-headered(
  [Смысл изоморфизма графов],
  [
    Глазами определить изоморфны ли нарисованные на бумажке графы очень легко (буквально одинаковые графы)

    Вся сложность задачи в алгоритмизации этого процесса, чтобы это могла делать машина.
  ],
)

#notes-header([Пути и связность], pgbreak: true)

#notes-sub([Пути])

#def(
  [Walk (переводить запрещено)],
  [
    переменная последовательность вершин и ребер.

    Замкнутый walk так и называется
  ],
)
#def(
  [Trail (переводить запрещено)],
  [
    walk, в котором ребра не повторяются.

    Замкнутый trail --- circuit
  ],
)
#def(
  [Путь (path)],
  [
    trail, в котором вершины не повторяются.

    Замкнутый путь --- цикл
  ],
)

Путь (и все остальные) называются замкнутыми если начинаются и заканчиваются в одной и той же вершине (в path допускается только такое повторение вершин)

#def(
  [Длина пути (и проч.)],
  [
    количество ребер в нем
  ],
)
#def(
  [Расстояние (между $u, v$)],
  [
    длина кратчайшего пути между $u$ и $v$. Если пути не существует, пишут $"dist"(u, v) = oo$
  ],
)

#theorem(
  [Расстояние --- метрика],
  [
    Проверить свойства несложно, доказательство тривиально
  ],
)

#fun-fact-headered(
  [Характеристики вершин и графов, связанные с расстоянием],
  [
    - *Эксцентриситет* вершины --- расстояние от нее до самой удаленной вершины ($"ecc"(v) = limits(max)_(u in V) "dist"(u, v)$)
    - *Радиус* графа --- минимальный эксцентриситет его вершин
    - *Диаметр* графа --- максимальный эксцентриситет его вершин
    - *Центр* графа --- множество вершин, эксцентриситет которых равен его радиусу
  ],
)

#theorem(
  [$ "rad"(G) <= "diam"(G) <= 2 dot "rad"(G) $],
  [
    - $"rad"(G) <= "diam"(G)$ --- очевидно из определения
    - Пусть $"diam"(G) = "dist"(u, v)$, а $w$ --- один из центров графа, тогда
    $
      "dist"(u, v) <= underbracket("dist"(u, w), <= "rad"(G)) + underbracket("dist"(w, v), <= "rad"(G)) <= 2 dot "rad"(G)
    $
  ],
)


#notes-sub([Связность], pgbreak: true)
#def(
  [Связность вершин],
  [
    вершины связаны если существует путь из одной в дргуую
  ],
)
#def(
  [Связность графа],
  [
    граф называется связным, если все его вершины связаны
  ],
)

#theorem(
  [Из существования walk следует существование пути],
  [
    Рассмотрим минимальный (по включению) walk, если есть повторяющиеся вершины получим противоречие --- walk не минимальный, откуда следует, что повторяющихся вершин (а значит и ребер) нет, а значит рассмотренный walk --- путь (если есть walk короче, также получим противоречие)
  ],
)

#def(
  [Компонента связности],
  [максимальный связный подграф],
)

Эти определения касались неориентированного графа, теперь что касается ориентированного.

#def(
  [Слабая связность],
  [
    если все ребра считать двунаправленными, граф становится связным
  ],
)
#def(
  [Полусвязность],
  [для любых двух вершин либо сущестует путь $u->v$ или $v->u$],
)
#def(
  [Сильная связность],
  [для любых двух вершин существует путь $u->v$ и $v->u$],
)

#def(
  [Компонента сильной связности],
  [
    максимальный сильно связный подграф ориентированного графа
  ],
)

#def(
  [Обхват (girth) графа],
  [
    длина кратчайшего цикла. Для ацикличного графа $"girth"(G) = oo$
  ],
)

#notes-header([Деревья и леса], pgbreak: true)

#def(
  [Дерево],
  [связный граф без циклов],
)
#def(
  [Лес],
  [граф без циклов],
)

#theorem(
  [
    Для графа $G$ с $n$ вершинами справедливо, что все следующие факты эквивалентны
    :
    + $G$ --- дерево
    + $G$ связный с $n-1$ ребром
    + $G$ ацикличный с $n-1$ ребром
    + Любые 2 вершины связаны единственным путем
    + $G$ минимально связный (удаление любого ребра нарушает связность)
    + $G$ максимально ацикличный (добавление любого ребра порождает цикл)
  ],
  [
    Докажем следствие $1 ==> 2 ==> 3 ==> 4 ==> 5 ==> 6 ==> 1$:

    - ($1 ==> 2$) Покажем, что не может быть меньше чем $n-1$ ребро. Рассмотрим граф из $n$ вершин без ребер, в нем $n$ компонент связности. Каждое ребро может соединить 2 вершины из одной компоненты связности (не изменить количество компонент связности) или из разных (уменьшить количество компонент связности на 1, если возможно), а значит чтобы граф был связным, нужно не меньше чем $n-1$ ребро. Теперь докажем, что если граф связный, то добавление любого ребра порождает цикл. Пусть добавилось ребро $e = {u, v}$, по предположению $u$ и $v$ связаны, то есть теперь есть путь из $u$ в $v$ (уже существовавший, без ребра $e$) и путь из $v$ в $u$ (по ребру $e$) --- цикл, а значит, если граф с $n-1$ вершиной связный, то больше в дереве быть уже не может (иначе появляется цикл)
    - ($2 ==> 3$) Связность включена. Докажем ацикличность --- от противного, если есть цикл, удалим ребро, граф должен остаться связным, но тогда в нем будет $n-2$ ребра, а в предыдущем пункте доказано, что в связном графе хотя бы $n - 1$ ребро $==>$ в исходном графе циклов не было
    - ($3 ==> 4$) Если есть больше 1 пути $u ~~> v$, то граф не акцикличный. По индукции докажем связность такого графа:
      - База --- граф с 2 вершинами и 1 ребром
      - Добавляем вершину, есть компонента связности и отдельная вершина, добавить можно только между двумя компонентами, иначе получится цикл в основной компоненте, то есть новый граф снова связный
    - ($4 ==> 5$) Любое ребро принадлежит какому-то единственному пути между вершинами и его удаление приведет к появлению второй компоненты связности
    - ($5 ==> 6$) Если исходный граф не ацикличный, то в нем есть ребро, удаление которого не нарушит связность --- противоречие. Также было доказано, что добавление ребра в связный граф ломает ацикличность $==>$ граф максимальный ацикличный
    - ($6 ==> 1$) Ацикличность уже есть. Пусть граф несвязный, тогда добавление ребра между разными компонентами связности, при этом цикла не появится --- противоречие
  ],
)

#def(
  [Подвешенное дерево (дерево с корнем)],
  [
    дерево, в котором одна вершина объявлена _корнем_.

    В подвешенном дереве (по опрределению)
    - Предок $v$ --- это сосед $v$ на пути к корню
    - Дети $v$ --- сосед $v$ вне пути к графу
    - Лист --- вершина без детей
    - Внутренняя вершина --- вершина с хотя бы 1 ребенком
  ],
)

#def(
  [Порожденное дерево],
  [
    порожденный подграф, являющийся деревом
  ],
)

#theorem(
  [Любой связный граф порождает хотя бы одно дерево],
  [
    Воспользуемся DFS --- если попадаем в вершину в которой уже были удалим последнее (ведущее в нее) ребро, как только алгоритм отработал не останется ни одного цикла, при этом не потеряется связность (удалялись только ребра, порождающие циклы)
  ],
)

Пусть теперь $T$ --- дерево, порожденное графом $G$, для любой вершины $e in E(G) smn E(T)$ граф $T + e$ содержит ровно 1 цикл, называемый фундаментальным циклом $e$ по отношению к дереву $T$

#def(
  [Prüfer-последовательность],
  [
    уникальный способ закодировать именованное дерево последовательностью из $n-2$ названий вершин (при $n$ вершинах)

    *Алгоритм построения*:
    + Выбрать лист с минимальным номером
    + Записать в последовательность его предка
    + Удалить лист
    + Повтоять пока не останется 2 вершины
  ],
)

#theorem(
  name: [Формула Кайли],
  [На $n$ вершинах можно построить ровно $n^(n-2)$ labeled деревьев],
  [
    Если поверить, что Prüfer-последовательность уникально кодирует ровно один граф, то доказательство этого факта очевидно следует из комбинаторики --- $n-2$ места, на каждом из которых стоит одно из $n$ названий вершин: $underbracket(n dot n dot dots dot n, n-2 "штуки") = n^(n-2)$
  ],
)

#notes-header([Теория связности], pgbreak: true)

#def(
  [Точка сочленения],
  [вершина, удаление которой увеличивает количество компонент связности],
)
#def(
  [Мост],
  [ребро, удаление которого увеличивает количество компонент связности],
)

#def(
  [$u$-$v$ разделитель (u-v вершинный срез)],
  [
    множество вершин\ $S subset.eq V smn {u, v}$, такое что в графе $G - S$ вершины $u$ и $v$ не связаны
  ],
)
#def(
  [$u$-$v$ реберный срез],
  [
    множество ребер $F subset.eq E$, при которых в графе $G - F$ вершины $u$ и $v$ лежат в разных компонентах связности
  ],
)

#def(
  [Внутренее непересекающиеся (по вершинам) пути],
  [
    2 пути из $u$ в $v$, которые не имеют общих вершин кроме $u$ и $v$
  ],
)
#def(
  [Внутренее непересекающиеся (по ребра) пути],
  [
    2 пути из $u$ в $v$, которые не имеют общих вершин ребер
  ],
)

#def(
  [Связность вершин],
  [
    $kappa(G)$ минимальное количество вершин, которое нужно удалить, чтобы граф стал несвязным или тривиальным
  ],
)
#def(
  [Связность ребер],
  [
    $lambda(G)$ минимальное количество ребер, которое нужно удалить, чтобы граф стал несвязным или тривиальным
  ],
)

#def(
  [$k$-связный граф],
  [
    граф называется $k$-связным, если $kappa(G) >= k$. Или, что эквивалентно, в $G$ не меньше $k$ вершин и $ (forall S)(abs(S) < k ==> (G-S) -"связный") $
  ],
)
#def(
  [$k$-реберно-связный граф],
  [
    граф называется $k$-реберно-связным, если $lambda(G) >= k$. Или, что эквивалентно, в $G$ не меньше $k$ вершин и $ (forall F)(abs(F) < k ==> (G-F) -"связный") $
  ],
)

#notes-sub([Эйлеровость], pgbreak: true)

#def(
  [Эйлеров путь],
  [
    путь, включающий в себя все ребра.

    Граф, в котором существует эйлеров путь называется *полуэйлеровым*.
  ],
)
#def(
  [Эйлеров цикл],
  [
    замкнутый эйлеров путь.

    Граф, в котором существует эйлеров цикл называется *эйлеровым*.
  ],
)
#fun-fact-headered(
  [Критерий эйлеровости для графа],
  [
    - *Неориентированный граф*:
      + Все вершины четной степени --- $(forall v in V(G))(deg (v) = 2n)$
      + Среди всех комопнент связности ребра содержит _ не более _ чем одна
      Второй пункт является объектом дискуссии --- _ считать ли тривиальный граф эйлеровым? _ если критерий такой, то ответ на вопрос --- да, если требовать _ ровно _ 1 компоненту связноси с ребрами, то нет
    - *Ориентированный граф*:
      + Степени входа и исхода для всех вершин совпадают ---\ $(forall v in V(G))(deg^- (v) = deg^+(v))$
      + Среди всех комопнент связности ребра содержит не более чем одна
  ],
)

#notes-sub([Гамильтоновость], pgbreak: true)
#def(
  [Гамильтонов путь],
  [
    путь, включающий в себя все вершины.

    Невероятно, но граф, в котором существует гамильтонов путь называется *полугамильтоновым*.
  ],
)
#def(
  [Гамильтонов цикл],
  [
    замкнутый гамильтонов путь.

    Граф, в котором существует гамильтонов цикл называется *гамильтоновым*.
  ],
)

#fun-fact(
  [
    Критерия гамильтоновости, к сожалению, пока никто не обнаружил, однако есть достаточное условие гамильтоновости (неориентированный граф):
    - _*Теорема Оре*_:
      #block(
        width: 100%,
        $
          n >= 3 "и" (forall u, v : {u, v} in.not E(G))(deg(u) + deg(v) >= n)
        $,
      )
    Также есть _ менее сильная _ теорема, которая однако следует из Оре, а значит так же является достаточным уловием. Речь о _*теореме Дирака*_:
    $
      n>=3 "и" (forall v in V(G))(deg(v) >= n/2)
    $
    *Внимание!* На практике нас прогрели --- теоремы не эквивалентны! Контр пример имени Чата Джи-Пи-Ти --- рассмотрим $K_5$ (полный граф из 5 вершин ${a, b, c, d, e}$), теперь добавим шестую вершину $f$ и ребра из нее в $a$ и $e$, таким образом получим граф, в котором будет гамильтонов цикл ($f->a->b->c->d->e->f$, проще нарисовать, но я, пожалуй, не буду), однако есть вершина $f$, для которой $deg(f) = 2 < n/2=6/2=3$, то есть условие Дирака не выполнено (а Оре --- выполнено)
  ],
)

#notes-sub([Реберная и вершинная двусвязность], pgbreak: true)
Сначала про _ реберную _ двусвязность
#def(
  [Двусвязные вершины],
  [
    вершины $u$ и $v$ называются двусвязными, если существует 2 реберно не пересекающихся пути между ними.

    Несложно доказать, что отношение "быть реберно двусвязными" на множестве вершин является отношением эквивалентности.
  ],
)

#def(
  [Мост (alt)],
  [ребро, соединяющее 2 компоненты реберной двусвязности.],
)

Теперь про _ вершинную _

#def(
  [Двусвязные ребра],
  [
    ребра, между которыми существует 2 вершинно не пересекающихся пути.

    Отношение на множестве ребер --- эквивалентность
  ],
)
#def(
  [Блок],
  [компонента вершинной двусвязности],
)
#def(
  [Точка сочленения (alt)],
  [вершина, соединяющая блоки],
)

#notes-sub([Полезные теоремы], pgbreak: true)

#theorem(
  name: [Неравенство Уитни],
  [
    Для любого графа
    $
      kappa(G) <= lambda(G) <= delta(G)
    $
  ],
  [
    - $lambda(G) <= delta(G)$. Рассмотрим вершину с минимальной степенью и удалим все инцидентные инцидентные им ребра
    - $kappa(G) <= lambda(G)$ TBD
  ],
)

#theorem(
  name: [Теорема Менгера (вершинная форма)],
  [
    Пусть $u$ и $v$ не соседние вершины, тогда максимальное количество вершинно не пересекающихся путей равно минимальному количеству вершин в вершинном $u$-$v$ разрезе
  ],
  [
    Пусть первое значение --- $p$, воторое --- $q$.
    - $p <= q$ тривиально --- пути не пересекаются, возьмем из каждого по одной произвольной вершине (разрез без хотя бы одной вершины из каждого пути будет неполным), а значит вершин в разрезе точно не меньше, чем путей
    - $p >= q$ TBD
  ],
)

#theorem(
  name: [Теорема Менгера (реберная форма)],
  [
    Пусть $u$ и $v$ различные вершины, тогда максимальное количество реберно не пересекающихся путей равно минимальному количеству ребер в реберном $u$-$v$ разрезе
  ],
  [
    // Пусть первое значение --- $p$, воторое --- $q$.
    // - $p <= q$ тривиально --- пути не пересекаются, возьмем из каждого по одной произвольной вершине (разрез без хотя бы одной вершины из каждого пути будет неполным), а значит вершин в разрезе точно не меньше, чем путей
    // - $p >= q$ TBD
  ],
)

Следующие штуки называют следствиями из теоремы Менгера

#theor-state(
  name: [Глобальная вершинная связность],
  [
    Граф $k$-вершинно связный $<==>$ все пары вершин между собой $k$-связны (вершинно)
  ],
)
#theor-state(
  name: [Глобальная реберная связность],
  [
    Граф $k$-реберно связный $<==>$ все пары вершин между собой $k$-связны (реберно)
  ],
)

#theorem(
  name: [Теорема (снова Уитни)],
  [Граф с хотя бы 3 вершинами двусвязный тогда и только тогда, когда любые 2 вершины лежат в цикле],
  [
    - ($=>$) есть минимум 2 не пересекающихся пути, объединим их и получим цикл
    - ($arrow.double.l$) есть цикл, удалим любую вершину, путь все равно останется $==>$ граф _ минимум _ 2-связный
  ],
)

#def(
  [ВС-дерево (block-cut tree)],
  [
    граф, которые дерево и
    + Есть вершины-блоки и вершины-точки сочленения
    + Вершины разных типов являются соседями, если точка сочленения лежит в блоке
  ],
)


#notes-header([Двудольные графы и паросочетания], pgbreak: true)
#def(
  [Двудольный граф],
  [
    граф называется двудольным, если
    $
      V(G) = X union.sq Y
    $
    причем
    $
      (forall x in X)(exists y in Y)({x, y} in E(G)) "и наоборот"
    $
    Можно обозначать как
    $
      G = pair(X union.sq Y, E)
    $
  ],
)

#theorem(
  [Граф двудольный $<==>$ в нем нет циклов нечетной длины],
  [],
)

#def(
  [Полный двудольный граф],
  [двудольный граф с максимальным количеством ребер],
)

#notes-sub([Паросочетания], pgbreak: true)

#def(
  [Паросочетание],
  [
    $M subset.eq E$, множество попарно не пересекающихся ребер.

    - *Максимальное* --- добавлять не получается
    - *Наибольшее* --- наибольшая мощность множеств
    - *Идеальное* --- покрывает все ребра
  ],
)



